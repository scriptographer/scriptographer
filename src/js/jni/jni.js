var printDetails = true;
var lineBreak = java.lang.System.getProperty('line.separator');

if (this.echo) {
	function write() {
		echo.setMessage(Array.prototype.slice.call(arguments).join(' ') || ' ');
		echo.execute();
	}
	// Under Ant, we're not printing details:
	printDetails = false;
} else {
	function write() {
		print(Array.prototype.slice.call(arguments).join(' '));
	}
}

function loadJniClasses(dir, endsWithMask) {
	dir = new java.io.File(dir);
	var classes = {};
	filter = new java.io.FilenameFilter() {
		accept: function(dir, name) {
			return new java.lang.String(name).endsWith(endsWithMask
					? endsWithMask : ".h");
		}
	}
	var lst = dir.listFiles(filter);
	for (var i=0; i < lst.length; i++) {
		collectJniClasses(lst[i], classes);
	}
	return classes;
}

/*
 * Parses .h files as generated by javah and creates a structure that contains
 * descriptions of all existing classes and functions
 */
function collectJniClasses(file, classes) {
	var reader = new java.io.BufferedReader(new java.io.FileReader(file)), line;
	while ((line = reader.readLine()) != null) {
		var m = line.match(/Class:(?:\s*)(.*)/);
		if (m) {
			var cls = m[1];
			// Create a structure for this class if it doesn't exist already:
			var functions = classes[cls] || [];
			// Now read the function:
			// Next line is the java function name:
			var func = { className: cls };
			m = reader.readLine().match(/Method:(?:\s*)(.*)/);
			if (m) {
				func.javaName = m[1];
				// Next line is the signature:
				m = reader.readLine().match(/Signature:(?:\s*)(.*)/);
				if (m) {
					func.signature = m[1];
					// Now skip the end line of the coment
					reader.readLine();
					// And read the jni function line:
					var declaration = reader.readLine();
					m = declaration.match(
							/(?:\s*)([^\s]*)(?:\s*)JNICALL(?:\s*)(.*)/);
					if (m) {
						func.declaration = declaration;
						func.returnType = m[1];
						func.jniName = m[2];
						// Read the params:
						m = reader.readLine().match(/(?:\s*)\((.*)\);/);
						if (m) {
							func.params = m[1];
							func.paramTypes = func.params.split(',');
							for (var i in func.paramTypes)
								func.paramTypes[i] = new java.lang.String(
										func.paramTypes[i]).trim();
	
							// Put the function code for this function into the
							// list of this class:
							functions.push(func);
						}
					}
				}
			}
			if (functions.length > 0) {
				classes[cls] = functions;
			}
		}
	}
}

/*
 * Parses a .cpp file previously generated by jni.js and creates a structure
 * that contains descriptions of all existing functions
 */
function collectJniBodies(file) {
	var reader = new java.io.BufferedReader(new java.io.FileReader(file));
	// Read all lines first, so we can check across multiple lines
	var lines = [], line;
	while ((line = reader.readLine()) != null)
		lines.push(line);
	reader.close();
	var functions = {};
	// Now abuse String#replace as an easy way to iterate through all matches.
	// [\u0000-\uffff]* is dot-all across multiple lines in JS.
	lines.join('\n').replace(
		/JNIEXPORT(?:\s+)(.*)(?:\s*)JNICALL(?:\s+)(.*)\(([\u0000-\uffff]*?)\)/g,
		function(all, type, name, params) {
			var func = {
				returnType: new java.lang.String(type).trim(),
				jniName: name,
				params: params
			};
			params = params.split(',');
			for (var i in params) {
				var m = params[i].match(/(?:\s*)([^\s]*)(?:\s*)([^\s]*)(?:\s*)/);
				if (m) {
					var param = m[1];
					// Handle pointers correctly:
					if (m[2].charAt(0) == '*')
						param += ' *';
					params[i] = param;
				}
			}
			func.paramTypes = params;
			functions[name] = func;
		}
	);
	return functions;
}

function JniTypeReader(str) {
	this.string = str;
	this.position = 0;
}

JniTypeReader.prototype = {
	readNext: function() {
		if (this.string && this.position < this.string.length) {
			var c = this.string.charAt(this.position);
			switch (c) {
				case 'Z':
					this.position++;
					return 'boolean';
				case 'B':
					this.position++;
					return 'byte';
				case 'C':
					this.position++;
					return 'char';
				case 'S':
					this.position++;
					return 'short';
				case 'I':
					this.position++;
					return 'int';
				case 'J':
					this.position++;
					return 'long';
				case 'F':
					this.position++;
					return 'float';
				case 'D':
					this.position++;
					return 'double';
				case 'V':
					this.position++;
					return 'void';
				case 'L': // Fully qualified class
					var m = this.string.substring(this.position).match(/L([^;]*);/);
					if (m) {
						var cls = m[1];
						this.position += cls.length + 2;
						return cls.replace(/\//gi, '.');
					}
				case '[': // Array
					this.position ++;
					return this.readNext() + '[]';
			}
		}
		return '';
	},

	readAll: function() {
		var list = [];
		do {
			var type = this.readNext();
			if (!type) break;
			list.push(type);
		} while (true);
		return list;
	}
};

function registerNatives(srcDir, output, uiClassFilter) {
	// TODO: Consider using Template.js for all this, for easier changeability

	// Read the files in the directory
	var classes = loadJniClasses(srcDir);
	
	// Now create the registerNatives file
	var file = new java.io.File(output);
	if (!file.exists()) file.createNewFile();
	var out = new java.io.PrintStream(new java.io.FileOutputStream(file));
	out.println('/* DO NOT EDIT THIS FILE - it is machine generated */');
	out.println('#include "stdHeaders.h"');
	out.println('#include "ScriptographerEngine.h"');
	out.println('#include <jni.h>');
	// Generate includes for all the classes:
	out.println();
	out.println('/* Include headers for all classes */');
	for (var cls in classes) {
		out.println('#include "' + cls + '.h"');
	}
	out.println();
 
	// First the method lists:
	for (var cls in classes) {
	
		if (excludeFromRegisterNatives(cls, uiClassFilter)) // exclude widget or
															// adm
			continue;
				
		write(cls + ".h:");
		if (printDetails)
			write();
		out.println('/* Native methods for class ' + cls + ' */');
		out.println('static const JNINativeMethod ' + cls + '_methods[] = {');
		var functions = classes[cls];
		for (var i in functions) {
			var func = functions[i];
			out.println('\t{ "' + func.javaName + '", "' + func.signature
					+ '", (void *) &' + func.jniName + ' }'
					+ (i < functions.length - 1 ? ',' : ''));
			if (printDetails)
				write('    ' + func.javaName);
		}
		out.println('};');
		out.println();
		if (printDetails)
			write();
	}

	// And now the register methods:
	out.println('/* Registers native methods for a given class */');
	out.println('void ScriptographerEngine::registerClassNatives(JNIEnv *env, const char *className, const JNINativeMethod *methods, int count) {');
	// Use the internal ScriptographerEngine::findClass instead of JNI's because
	// this one loads with the Scriptographer loader!
	out.println('\tjclass cls = findClass(env, className);');
	out.println('\tif (cls == NULL)');
	out.println('\t\tthrow new StringException("Cannot register native methods for class %s: Class not found.", className);');
	out.println('\t// Call getConstructors on each class to fix a bug in JSE 1.6.');
	out.println('\t// Only by doing so, the registered natives do not get lost!');
	out.println('\tcallObjectMethod(env, cls, mid_Class_getConstructors);');
	out.println('\t// Now we can register the native methods.');
	out.println('\tjint err = env->RegisterNatives(cls, methods, count);');
	out.println('\tif (err != 0)');
	out.println('\t\tthrow new StringException("Cannot register native methods for class %s.", className);');
	out.println('}');
	out.println();
	out.println('/* Registers native methods for all classes, to be called from outside */');
	out.println('void ScriptographerEngine::registerNatives(JNIEnv *env) {');
	for (var cls in classes) {
		
		if (excludeFromRegisterNatives(cls, uiClassFilter)) // exclude widget or
															// adm
			continue;
					
		out.println('\tregisterClassNatives(env, "' + cls.replace(/_/gi, '/') + '", ' + cls + '_methods,');
		out.println('\t\tsizeof(' + cls + '_methods) / sizeof(JNINativeMethod));');
		out.println();
	}
	out.println('}');
}

function excludeFromRegisterNatives(clsName, uiClassFilter)// exclude widget or
															// adm
{
	if (typeof uiClassFilter === 'undefined' || uiClassFilter == 'adm')
		uiExcludeFilter = 'widget';
	else
		uiExcludeFilter = 'adm';
	write(clsName);
	if (java.lang.String(clsName).indexOf(uiExcludeFilter) >= 0)
		return true;
	return false;
}

function createJniBodies(srcDir, endsWithMask) {
	// Read the files in the directory
	var classes = loadJniClasses(srcDir, endsWithMask);

	for (var cls in classes) {
		var file = new java.io.File(srcDir, cls + ".cpp");
		
		var existingBodies = file.exists() ? collectJniBodies(file) : null;
		
		write(cls + ".cpp: " + (existingBodies ? " appending..." : "creating..."));
		if (printDetails)
			write();
		file.createNewFile();
		var out = new java.io.PrintStream(new java.io.FileOutputStream(file,
				!!existingBodies));

		if (!existingBodies) {
			// Normal include: out.println('#include <jni.h>');
			// Custom includes:
			// TODO: Add Scriptographer header through Template.js?
			out.println('#include "StdHeaders.h"');
			out.println('#include "ScriptographerEngine.h"');
			// Custom end
			
			// Include class header as well:
			out.println('#include "' + cls + '.h"');
			out.println();
			out.println('/*');
			out.println(' * ' + cls.replace(/_/gi, '.'));
			out.println(' */');
		}
	
		var functions = classes[cls];
		var first = true;
		for (var i in functions) {
			var func = functions[i];
			// Convert the signature to a correct java-like comment:
			var m = func.signature.match(/\((.*)\)(.*)/);
			if (m) {
				// Use the JniTypeReader to conver the types:
				var params = m[1];
				var ret = m[2];
				
				params = new JniTypeReader(params).readAll();
				// Add the param names, as used bellow for the C function:
				for (var i = 0; i < params.length; i++) {
					params[i] += ' ' + 'arg' + (i + 1);
				}
				var javaDecl = new JniTypeReader(ret).readNext() + ' '
						+ func.javaName + '(' + params.join(', ') + ')';

				// Add a line break after '('
				var jniDecl = func.declaration + '(' + lineBreak + '\t\t';
				for (var i in func.paramTypes) {
					var param = func.paramTypes[i];
					jniDecl += param;
					if (param == 'JNIEnv *') jniDecl += 'env';
					else {
						jniDecl += ' '; // no space needed for env!
						if (i < 2) {
							if (param == 'jclass') jniDecl += 'cls';
							else if (param == 'jobject') jniDecl += 'obj';
						} else jniDecl += 'arg' + (i - 1);
					} 
					if (i < func.paramTypes.length - 1) jniDecl += ', ';
				}
				jniDecl += ')';
				
				// Now if we're appending to an existing file, only appendChild
				// this function if there is not alreaddy a body for it.
				// Functions that have changed in the meantime will be appended
				// again, causing a compiler-error that then can be corrected
				// manually.
				
				var append = true;
				
				if (existingBodies) {
					var body = existingBodies[func.jniName];
					if (body) {
						append = !(func.paramTypes.join().equals(body.paramTypes.join())
								&& func.returnType.equals(body.returnType));
						if (printDetails && !append) {
							if (first) write();
							first = false;
							write('        Defined: ' + func.jniName);
						}
					}
					// Now remove it and see what remains in the end:
					delete existingBodies[func.jniName];
				}
				if (append) {
					if (first) write();
					first = false;
					write('    New: ' + jniDecl);
					
					out.println();
					out.println('/*');
					out.println(' * ' + javaDecl);
					out.println(' */');
					out.println(jniDecl + ' {');
					
					// Custom function definition
					out.println('\ttry {');
					out.println('\t\t// TODO: define ' + func.javaName);
					out.println('\t} EXCEPTION_CONVERT(env);');
					// Custom end
					
					switch (ret.charAt(0)) {
					case 'V': // void
						// Do nothing
						break;
					case 'Z': // Boolean
						out.println('\treturn false;');
						break;
					case 'C': //
						out.println('\treturn \' \';');
						break;
					case 'L':
					case '[':
						out.println('\treturn NULL;');
						break;
					case 'F':
					case 'D':
						out.println('\treturn 0.0;');
						break;
					default:
						out.println('\treturn 0;');
						break;
					}
					out.println('}');
				}
			}
		}
		if (existingBodies) {
			for (var n in existingBodies) {
				if (first) write();
				first = false;
				write('    Unused: ' + n);
			}
			if (!first)
				write();
		}
		if (printDetails)
			write();
	}
}
